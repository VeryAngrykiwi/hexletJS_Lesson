/*Задача
Функция Аккермана — простой пример вычислимой функции, которая не является примитивно рекурсивной.
Она обозначается A(m,n), принимает два неотрицательных целых числа в качестве параметров и возвращает натуральное число. Эта функция растёт очень быстро, например, число A(4,4) настолько велико, что количество цифр в порядке этого числа многократно превосходит количество атомов в наблюдаемой части Вселенной.
Функция Аккермана определяется рекурсивно для неотрицательных целых чисел m и n следующим образом:
Реализуйте и экспортируйте по умолчанию функцию Аккермана.
*/

//replit
const A = (m, n) => {
  if (m === 0) {
    return n + 1;
  }
  if (n === 0) {
    return A(m - 1, 1);
  }
  return A(m - 1, A(m, n - 1));
};

console.log(A(4, 4));

/*Базовый случай 1 (m === 0):
Если m равно 0, функция возвращает n + 1. Это базовый случай, который останавливает рекурсию.
Базовый случай 2 (n === 0):
Если n равно 0, функция делает рекурсивный вызов A(m - 1, 1). Это также базовый случай, который приводит к уменьшению m и установке n в 1.
Шаг рекурсии (return A(m - 1, A(m, n - 1));):
В остальных случаях, функция делает два рекурсивных вызова: A(m - 1, A(m, n - 1)). Это позволяет функции перемещаться вглубь структуры, используя рекурсию.
Пример вызова A(4, 4):
Вызов A(4, 4) приводит к нескольким вложенным рекурсивным вызовам, в результате чего будет выполнено большое количество вычислений.
Общая идея заключается в том, что алгоритм Аккермана быстро растет с увеличением аргументов, что делает его эффективным для тестирования производительности рекурсивных алгоритмов. Однако, из-за своего быстрого роста, его использование с большими значениями аргументов может привести к переполнению стека и занять много времени.
*/

//replit chatGPT
export const ackermann = (m, n) => {
  // Базовый случай 1: если m равно 0, возвращаем n + 1
  if (m === 0) {
    return n + 1;
  }

  // Базовый случай 2: если m > 0 и n равно 0, делаем рекурсивный вызов с m - 1 и 1
  if (m > 0 && n === 0) {
    return ackermann(m - 1, 1);
  }

  // Общий случай: если m > 0 и n > 0, делаем два рекурсивных вызова
  if (m > 0 && n > 0) {
    return ackermann(m - 1, ackermann(m, n - 1));
  }

  // В случае некорректных входных данных возвращаем undefined
  return undefined;
};

/*Теперь детальное объяснение:
Базовый случай 1 (m === 0):
Если m равно 0, то это базовый случай. В этом случае, функция возвращает n + 1. Это связано с особенностями определения функции Аккермана для m = 0.
Базовый случай 2 (m > 0 && n === 0):
Если m больше 0 и n равно 0, это также базовый случай. В этом случае, функция делает рекурсивный вызов ackermann(m - 1, 1). Этот случай также имеет свое значение в определении функции Аккермана.
Общий случай (m > 0 && n > 0):
Если m больше 0 и n больше 0, это общий случай. В этом случае, функция делает два рекурсивных вызова: ackermann(m - 1, ackermann(m, n - 1)). Это соответствует основному определению функции Аккермана.
Случай некорректных входных данных (return undefined;):
В случае, если введены некорректные значения m или n (например, отрицательные числа), функция возвращает undefined.
Функция Аккермана известна своей экспоненциальной сложность, и она растет очень быстро с увеличением значений m и n. Важно использовать ее с осторожностью и понимать, что для больших значений аргументов может потребоваться много ресурсов и времени.
*/